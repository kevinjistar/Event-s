# Event’s — Architecture Technique & Standards de Code

**Version 1.0 | Document de Référence Technique**  
*Ce document définit l’architecture, les standards de développement et les bonnes pratiques immuables pour Event’s.*

-----

## 1. PHILOSOPHIE TECHNIQUE

### Vision Technique

**“Simple, Scalable, Secure”**

Event’s doit être construit avec des technologies éprouvées, une architecture claire et une maintenabilité maximale.

### Principes Fondamentaux

#### 1. **Convention over Configuration**

- Structure de projet standardisée
- Nommage cohérent et prévisible
- Moins de décisions arbitraires, plus de patterns établis

#### 2. **Progressive Enhancement**

- L’app doit fonctionner sans JavaScript avancé
- Enrichissement progressif des fonctionnalités
- Graceful degradation sur anciens navigateurs

#### 3. **Performance First**

- Time to Interactive < 3s sur 3G
- Bundle JavaScript < 200KB (gzipped)
- Lighthouse Score > 90

#### 4. **Security by Design**

- Validation côté client ET serveur
- Firestore Security Rules strictes
- Authentification sécurisée (pas de stockage de tokens en clair)

-----

## 2. STACK TECHNIQUE

### Frontend

**Framework Principal :** React 18+ avec TypeScript

**Raisons du choix :**

- Écosystème mature et stable
- Performance optimale avec Concurrent Mode
- Type safety avec TypeScript
- Courbe d’apprentissage acceptable

**Build Tool :** Vite 5+

**Raisons du choix :**

- Hot Module Replacement ultra-rapide
- Build optimisé pour production
- Support natif TypeScript
- Configuration minimale

**Styling :** Tailwind CSS 3+

**Raisons du choix :**

- Utility-first approach (cohérent avec Design System)
- Purge CSS automatique
- Pas de conflits de nommage
- Customisation complète via config

**State Management :** React Context + Zustand (si nécessaire)

**Raisons du choix :**

- Context API suffit pour MVP
- Zustand si besoin d’état global complexe (léger, simple)
- Pas de Redux (trop verbose pour notre cas)

**Routing :** React Router v6+

**Raisons du choix :**

- Standard de facto React
- Nested routes pour architecture modulaire
- Lazy loading natif

**Librairies UI Additionnelles :**

- **Framer Motion** : Animations fluides
- **React Hook Form** : Gestion formulaires performante
- **date-fns** : Manipulation dates (plus léger que moment.js)
- **Lucide React** : Icônes (cohérent avec Design System)

### Backend (BaaS)

**Firebase Platform :**

- **Authentication** : Gestion utilisateurs (Google OAuth, Email/Password)
- **Firestore** : Base de données NoSQL temps réel
- **Cloud Functions** : Logique serveur (Node.js 20)
- **Cloud Storage** : Photos de profil, images événements
- **Firebase Hosting** : Déploiement frontend (PWA-ready)
- **Firebase Cloud Messaging (FCM)** : Notifications push

**Raisons du choix Firebase :**

- Time to market rapide (pas de backend à construire)
- Scalabilité automatique
- Real-time synchronisation native
- Sécurité robuste avec Security Rules
- Coût initial très bas (Free tier généreux)

### IA & Services Externes

**Google AI Studio (Gemini API)** : IA conversationnelle, suggestions, résumés

**Raisons du choix :**

- Intégration native Firebase/Google Cloud
- Modèle Gemini performant et économique
- Multimodalité (texte + images si besoin V2+)

**Services Additionnels (Phase 2+) :**

- **Google Maps API** : Localisation lieux d’événements
- **OpenWeatherMap API** : Suggestions basées météo
- **Stripe API** : Paiements (si Phase 3)

### DevOps & CI/CD

**Version Control :** Git + GitHub

**CI/CD :** GitHub Actions

**Workflow :**

```yaml
# .github/workflows/deploy.yml
name: Deploy to Firebase
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run build
      - run: npm run test
      - uses: FirebaseExtended/action-hosting-deploy@v0
```

**Monitoring :** Firebase Performance Monitoring + Analytics

**Error Tracking :** Sentry (gratuit jusqu’à 5K events/mois)

-----

## 3. ARCHITECTURE FIRESTORE

### Collections & Documents

```javascript
// Structure Firestore canonique
firestore/
├── users/
│   └── {userId}
│       ├── name: string
│       ├── email: string
│       ├── photoURL: string
│       ├── fcmToken: string
│       ├── createdAt: timestamp
│       ├── preferences: {
│       │   availabilities: "weekdays" | "weekends" | "both"
│       │   notificationsEnabled: boolean
│       │   language: "fr" | "en"
│       │ }
│       └── stats: {
│           eventsCreated: number
│           eventsAttended: number
│           reliabilityScore: number // 0-100
│         }
│
├── groups/
│   └── {groupId}
│       ├── name: string
│       ├── description: string
│       ├── privacy: "public" | "private"
│       ├── coverPhotoURL: string
│       ├── createdBy: string // userId
│       ├── createdAt: timestamp
│       └── members: [
│           {
│             userId: string
│             role: "creator" | "co-organizer" | "member"
│             joinedAt: timestamp
│           }
│         ]
│
├── events/
│   └── {eventId}
│       ├── groupId: string
│       ├── title: string
│       ├── description: string
│       ├── status: "idea" | "voting" | "pending_validation" | "confirmed" | "past" | "cancelled"
│       ├── createdBy: string // userId
│       ├── organizerIds: [string] // array of userId
│       ├── createdAt: timestamp
│       ├── updatedAt: timestamp
│       │
│       ├── dateOptions: [
│       │   {
│       │     optionId: string
│       │     start: timestamp
│       │     end: timestamp
│       │     proposedBy: string // userId
│       │     votes: [
│       │       {
│       │         userId: string
│       │         response: "yes" | "maybe" | "no"
│       │         votedAt: timestamp
│       │       }
│       │     ]
│       │   }
│       │ ]
│       │
│       ├── chosenDate: {
│       │   start: timestamp
│       │   end: timestamp
│       │   confirmedBy: string // userId
│       │   confirmedAt: timestamp
│       │ }
│       │
│       ├── location: {
│       │   name: string
│       │   address: string
│       │   coordinates: { lat: number, lng: number }
│       │ }
│       │
│       ├── contributions: [
│       │   {
│       │     contributionId: string
│       │     item: string
│       │     takenBy: string // userId ou null
│       │     quantity: number
│       │     addedAt: timestamp
│       │   }
│       │ ]
│       │
│       ├── expenses: {
│       │   paymentLink: string
│       │   totalAmount: number
│       │   whoPaid: [string] // array of userId
│       │ }
│       │
│       └── messages/ (subcollection)
│           └── {messageId}
│               ├── senderId: string
│               ├── text: string
│               ├── timestamp: timestamp
│               └── type: "text" | "system" // "system" pour notifications auto
│
└── notifications/
    └── {userId}
        └── {notificationId}
            ├── type: "vote_reminder" | "event_confirmed" | "new_message"
            ├── eventId: string
            ├── title: string
            ├── body: string
            ├── read: boolean
            ├── createdAt: timestamp
            └── actionURL: string
```

### Indexes Composites Requis

```javascript
// firestore.indexes.json
{
  "indexes": [
    {
      "collectionGroup": "events",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "groupId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "notifications",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "read", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    }
  ]
}
```

### Firestore Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isMemberOfGroup(groupId) {
      return exists(/databases/$(database)/documents/groups/$(groupId)) &&
             request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.members[*].userId;
    }
    
    function isEventOrganizer(eventId) {
      let eventData = get(/databases/$(database)/documents/events/$(eventId)).data;
      return request.auth.uid == eventData.createdBy ||
             request.auth.uid in eventData.organizerIds;
    }
    
    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(userId);
      allow update, delete: if isOwner(userId);
    }
    
    // Groups collection
    match /groups/{groupId} {
      allow read: if isAuthenticated() && 
                     (resource.data.privacy == "public" || isMemberOfGroup(groupId));
      allow create: if isAuthenticated();
      allow update: if isMemberOfGroup(groupId);
      allow delete: if isEventOrganizer(groupId);
    }
    
    // Events collection
    match /events/{eventId} {
      allow read: if isAuthenticated() && isMemberOfGroup(resource.data.groupId);
      allow create: if isAuthenticated() && isMemberOfGroup(request.resource.data.groupId);
      allow update: if isMemberOfGroup(resource.data.groupId);
      allow delete: if isEventOrganizer(eventId);
      
      // Messages subcollection
      match /messages/{messageId} {
        allow read: if isAuthenticated() && isMemberOfGroup(get(/databases/$(database)/documents/events/$(eventId)).data.groupId);
        allow create: if isAuthenticated() && isMemberOfGroup(get(/databases/$(database)/documents/events/$(eventId)).data.groupId);
        allow update, delete: if isOwner(resource.data.senderId);
      }
    }
    
    // Notifications collection
    match /notifications/{userId}/{notificationId} {
      allow read, write: if isOwner(userId);
    }
  }
}
```

-----

## 4. STRUCTURE DE PROJET FRONTEND

```
events-app/
├── public/
│   ├── favicon.ico
│   ├── manifest.json
│   └── icons/
│       ├── icon-192x192.png
│       └── icon-512x512.png
│
├── src/
│   ├── main.tsx                 # Point d'entrée
│   ├── App.tsx                  # Component racine
│   │
│   ├── assets/                  # Images, fonts statiques
│   │   ├── images/
│   │   └── fonts/
│   │
│   ├── components/              # Composants réutilisables
│   │   ├── common/              # Composants génériques
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Avatar.tsx
│   │   │   ├── Badge.tsx
│   │   │   ├── Card.tsx
│   │   │   └── Modal.tsx
│   │   │
│   │   ├── layout/              # Layout components
│   │   │   ├── Header.tsx
│   │   │   ├── BottomNav.tsx
│   │   │   └── Sidebar.tsx
│   │   │
│   │   └── features/            # Composants métier
│   │       ├── EventCard.tsx
│   │       ├── VoteModule.tsx
│   │       ├── ChatMessage.tsx
│   │       └── GroupCard.tsx
│   │
│   ├── pages/                   # Pages (routes)
│   │   ├── Dashboard.tsx
│   │   ├── Profile.tsx
│   │   ├── GroupList.tsx
│   │   ├── GroupDetail.tsx
│   │   ├── EventList.tsx
│   │   ├── EventDetail.tsx
│   │   └── Auth/
│   │       ├── Login.tsx
│   │       └── Register.tsx
│   │
│   ├── hooks/                   # Custom React Hooks
│   │   ├── useAuth.ts
│   │   ├── useFirestore.ts
│   │   ├── useRealtimeEvents.ts
│   │   ├── useNotifications.ts
│   │   └── useVoting.ts
│   │
│   ├── contexts/                # React Contexts
│   │   ├── AuthContext.tsx
│   │   ├── ThemeContext.tsx
│   │   └── NotificationContext.tsx
│   │
│   ├── services/                # Services externes
│   │   ├── firebase.ts          # Config Firebase
│   │   ├── auth.service.ts
│   │   ├── firestore.service.ts
│   │   ├── storage.service.ts
│   │   ├── ai.service.ts        # Google AI Studio
│   │   └── notifications.service.ts
│   │
│   ├── utils/                   # Utilitaires
│   │   ├── date.utils.ts
│   │   ├── validation.utils.ts
│   │   ├── format.utils.ts
│   │   └── constants.ts
│   │
│   ├── types/                   # TypeScript types
│   │   ├── user.types.ts
│   │   ├── group.types.ts
│   │   ├── event.types.ts
│   │   └── common.types.ts
│   │
│   ├── styles/                  # Styles globaux
│   │   ├── index.css            # Tailwind imports
│   │   └── animations.css       # Animations custom
│   │
│   └── config/                  # Configuration
│       ├── env.ts               # Variables d'environnement
│       └── routes.ts            # Définition des routes
│
├── .env.local                   # Variables d'environnement (git-ignored)
├── .env.example                 # Template variables d'environnement
├── .gitignore
├── package.json
├── tsconfig.json
├── vite.config.ts
├── tailwind.config.js
├── postcss.config.js
└── README.md
```

-----

## 5. STANDARDS DE CODE

### TypeScript

**Configuration tsconfig.json :**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@pages/*": ["src/pages/*"],
      "@hooks/*": ["src/hooks/*"],
      "@services/*": ["src/services/*"],
      "@utils/*": ["src/utils/*"],
      "@types/*": ["src/types/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

**Règles de Nommage :**

```typescript
// Fichiers : PascalCase pour composants, camelCase pour utilitaires
// ✅ Correct
EventCard.tsx
useAuth.ts
date.utils.ts

// ❌ Incorrect
eventCard.tsx
UseAuth.ts
Date.Utils.ts

// Types : PascalCase + suffixe descriptif
type User = { ... }
interface EventData { ... }
enum EventStatus { ... }

// Variables : camelCase
const userName = "Alice";
let eventCount = 0;

// Constantes : UPPER_SNAKE_CASE
const API_URL = "https://api.events.app";
const MAX_PARTICIPANTS = 12;

// Fonctions : camelCase, verbes pour actions
function getUserById(id: string): User { ... }
function createEvent(data: EventData): Event { ... }

// Composants React : PascalCase
const EventCard: React.FC<EventCardProps> = ({ ... }) => { ... }

// Custom Hooks : camelCase + préfixe "use"
function useAuth() { ... }
function useRealtimeEvents(groupId: string) { ... }
```

**Types Définitions (Exemples) :**

```typescript
// src/types/event.types.ts
export type EventStatus = 
  | "idea" 
  | "voting" 
  | "pending_validation" 
  | "confirmed" 
  | "past" 
  | "cancelled";

export type VoteResponse = "yes" | "maybe" | "no";

export interface DateOption {
  optionId: string;
  start: Date;
  end: Date;
  proposedBy: string;
  votes: Vote[];
}

export interface Vote {
  userId: string;
  response: VoteResponse;
  votedAt: Date;
}

export interface Event {
  id: string;
  groupId: string;
  title: string;
  description: string;
  status: EventStatus;
  createdBy: string;
  organizerIds: string[];
  dateOptions: DateOption[];
  chosenDate?: {
    start: Date;
    end: Date;
    confirmedBy: string;
    confirmedAt: Date;
  };
  location?: {
    name: string;
    address: string;
    coordinates?: { lat: number; lng: number };
  };
  contributions?: Contribution[];
  expenses?: Expenses;
  createdAt: Date;
  updatedAt: Date;
}

export interface Contribution {
  contributionId: string;
  item: string;
  takenBy: string | null;
  quantity: number;
  addedAt: Date;
}

export interface Expenses {
  paymentLink?: string;
  totalAmount: number;
  whoPaid: string[];
}
```

### React Components

**Conventions :**

```typescript
// ✅ Functional Component avec TypeScript
import React from 'react';

interface EventCardProps {
  event: Event;
  onVote: (optionId: string, response: VoteResponse) => void;
  className?: string; // Toujours optionnel
}

export const EventCard: React.FC<EventCardProps> = ({ 
  event, 
  onVote,
  className = '' 
}) => {
  // Hooks en premier (ordre : useState, useEffect, useMemo, useCallback, custom hooks)
  const [isExpanded, setIsExpanded] = React.useState(false);
  
  React.useEffect(() => {
    // Side effects
  }, []);
  
  const handleVote = React.useCallback((optionId: string) => {
    onVote(optionId, 'yes');
  }, [onVote]);
  
  // Early returns
  if (!event) return null;
  
  // Render
  return (
    <div className={`event-card ${className}`}>
      {/* JSX */}
    </div>
  );
};

// Pas de default export sauf pour pages (lazy loading)
```

**Destructuring Props :**

```typescript
// ✅ Correct : Destructure dans les paramètres
const Button: React.FC<ButtonProps> = ({ label, onClick, variant = 'primary' }) => {
  return <button onClick={onClick}>{label}</button>;
};

// ❌ Incorrect : Destructure dans le body
const Button: React.FC<ButtonProps> = (props) => {
  const { label, onClick, variant } = props;
  return <button onClick={onClick}>{label}</button>;
};
```

**Conditional Rendering :**

```typescript
// ✅ Correct : Ternaire pour JSX alternatif
{isLoading ? <Spinner /> : <Content />}

// ✅ Correct : && pour affichage conditionnel
{hasError && <ErrorMessage />}

// ❌ Incorrect : if/else dans JSX
{if (isLoading) { return <Spinner />; } else { return <Content />; }}
```

### Hooks Personnalisés

```typescript
// src/hooks/useAuth.ts
import { useState, useEffect } from 'react';
import { onAuthStateChanged } from 'firebase/auth';
import { auth } from '@services/firebase';
import type { User } from '@types/user.types';

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(
      auth,
      (firebaseUser) => {
        if (firebaseUser) {
          // Map Firebase User to App User
          setUser({
            id: firebaseUser.uid,
            email: firebaseUser.email!,
            name: firebaseUser.displayName || '',
            photoURL: firebaseUser.photoURL || '',
          });
        } else {
          setUser(null);
        }
        setLoading(false);
      },
      (err) => {
        setError(err);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, []);

  return { user, loading, error };
}
```

### Services

```typescript
// src/services/firestore.service.ts
import { 
  collection, 
  doc, 
  getDoc, 
  getDocs, 
  addDoc, 
  updateDoc, 
  deleteDoc,
  query,
  where,
  orderBy,
  Timestamp 
} from 'firebase/firestore';
import { db } from './firebase';
import type { Event, EventStatus } from '@types/event.types';

export class FirestoreService {
  // Collections refs
  private static readonly EVENTS = 'events';
  private static readonly GROUPS = 'groups';
  private static readonly USERS = 'users';

  // Create
  static async createEvent(eventData: Omit<Event, 'id'>): Promise<string> {
    try {
      const docRef = await addDoc(collection(db, this.EVENTS), {
        ...eventData,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
      });
      return docRef.id;
    } catch (error) {
      console.error('Error creating event:', error);
      throw new Error('Failed to create event');
    }
  }

  // Read
  static async getEventById(eventId: string): Promise<Event | null> {
    try {
      const docSnap = await getDoc(doc(db, this.EVENTS, eventId));
      if (!docSnap.exists()) return null;
      
      return {
        id: docSnap.id,
        ...docSnap.data(),
      } as Event;
    } catch (error) {
      console.error('Error fetching event:', error);
      throw new Error('Failed to fetch event');
    }
  }

  // Query
  static async getEventsByGroup(
    groupId: string, 
    status?: EventStatus
  ): Promise<Event[]> {
    try {
      let q = query(
        collection(db, this.EVENTS),
        where('groupId', '==', groupId),
        orderBy('createdAt', 'desc')
      );

      if (status) {
        q = query(q, where('status', '==', status));
      }

      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
      })) as Event[];
    } catch (error) {
      console.error('Error querying events:', error);
      throw new Error('Failed to query events');
    }
  }

  // Update
  static async updateEvent(
    eventId: string, 
    updates: Partial<Event>
  ): Promise<void> {
    try {
      await updateDoc(doc(db, this.EVENTS, eventId), {
        ...updates,
        updatedAt: Timestamp.now(),
      });
    } catch (error) {
      console.error('Error updating event:', error);
      throw new Error('Failed to update event');
    }
  }

  // Delete
  static async deleteEvent(eventId: string): Promise<void> {
    try {
      await deleteDoc(doc(db, this.EVENTS, eventId));
    } catch (error) {
      console.error('Error deleting event:', error);
      throw new Error('Failed to delete event');
    }
  }
}
```

### Utilitaires

```typescript
// src/utils/date.utils.ts
import { format, formatDistance, isAfter, isBefore, addDays } from 'date-fns';
import { fr } from 'date-fns/locale';

export class DateUtils {
  // Format date pour affichage
  static formatEventDate(date: Date): string {
    return format(date, 'EEEE d MMMM yyyy', { locale: fr });
  }

  // Format heure
  static formatEventTime(date: Date): string {
    return format(date, 'HH:mm', { locale: fr });
  }

  // Distance relative ("dans 2 jours")
  static getRelativeTime(date: Date): string {
    return formatDistance(date, new Date(), { 
      addSuffix: true, 
      locale: fr 
    });
  }

  // Vérifier si événement est urgent (<48h)
  static isEventUrgent(date: Date): boolean {
    const urgentThreshold = addDays(new Date(), 2);
    return isBefore(date, urgentThreshold) && isAfter(date, new Date());
  }

  // Vérifier si événement est passé
  static isEventPast(date: Date): boolean {
    return isBefore(date, new Date());
  }
}
```

### Validation

```typescript
// src/utils/validation.utils.ts
export class ValidationUtils {
  // Email
  static isValidEmail(email: string): boolean {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  }

  // Titre événement
  static isValidEventTitle(title: string): boolean {
    return title.trim().length >= 3 && title.trim().length <= 100;
  }

  // Date future
  static isFutureDate(date: Date): boolean {
    return date > new Date();
  }

  // Nombre participants
  static isValidParticipantCount(count: number): boolean {
    return count >= 2 && count <= 50; // Ajustable selon besoins
  }

  // Sanitize input (prévention XSS basique)
  static sanitizeInput(input: string): string {
    return input
      .trim()
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }
}
```

### Constantes

```typescript
// src/utils/constants.ts
export const APP_CONFIG = {
  NAME: 'Event\'s',
  VERSION: '1.0.0',
  MIN_GROUP_SIZE: 4,
  MAX_GROUP_SIZE: 12,
  MIN_EVENT_TITLE_LENGTH: 3,
  MAX_EVENT_TITLE_LENGTH: 100,
  MIN_DATE_OPTIONS: 2,
  MAX_DATE_OPTIONS: 5,
  VOTE_DEADLINE_HOURS: 48,
  AUTO_VALIDATE_THRESHOLD: 0.8, // 80%
} as const;

export const EVENT_STATUS = {
  IDEA: 'idea',
  VOTING: 'voting',
  PENDING_VALIDATION: 'pending_validation',
  CONFIRMED: 'confirmed',
  PAST: 'past',
  CANCELLED: 'cancelled',
} as const;

export const VOTE_RESPONSE = {
  YES: 'yes',
  MAYBE: 'maybe',
  NO: 'no',
} as const;

export const ROUTES = {
  HOME: '/',
  DASHBOARD: '/dashboard',
  PROFILE: '/profile',
  GROUPS: '/groups',
  GROUP_DETAIL: '/groups/:groupId',
  EVENTS: '/events',
  EVENT_DETAIL: '/events/:eventId',
  LOGIN: '/login',
  REGISTER: '/register',
} as const;
```

-----
## 6. GESTION DES ERREURS

### Frontend

```typescript
// src/utils/error.utils.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export const ERROR_CODES = {
  // Auth
  AUTH_REQUIRED: 'AUTH_REQUIRED',
  INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
  EMAIL_ALREADY_EXISTS: 'EMAIL_ALREADY_EXISTS',
  
  // Firestore
  DOCUMENT_NOT_FOUND: 'DOCUMENT_NOT_FOUND',
  PERMISSION_DENIED: 'PERMISSION_DENIED',
  NETWORK_ERROR: 'NETWORK_ERROR',
  
  // Validation
  INVALID_INPUT: 'INVALID_INPUT',
  MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',
  
  // Business Logic
  EVENT_ALREADY_CONFIRMED: 'EVENT_ALREADY_CONFIRMED',
  NOT_GROUP_MEMBER: 'NOT_GROUP_MEMBER',
  VOTE_DEADLINE_PASSED: 'VOTE_DEADLINE_PASSED',
} as const;

// Error Handler Hook
export function useErrorHandler() {
  const [error, setError] = useState<AppError | null>(null);

  const handleError = useCallback((err: unknown) => {
    if (err instanceof AppError) {
      setError(err);
    } else if (err instanceof Error) {
      setError(new AppError(err.message, 'UNKNOWN_ERROR'));
    } else {
      setError(new AppError('Une erreur inconnue est survenue', 'UNKNOWN_ERROR'));
    }
    
    // Log to Sentry in production
    if (import.meta.env.PROD) {
      console.error('[ERROR]', err);
      // Sentry.captureException(err);
    }
  }, []);

  const clearError = useCallback(() => setError(null), []);

  return { error, handleError, clearError };
}
```

### Cloud Functions

```typescript
// functions/src/utils/errors.ts
export class FunctionError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = 'FunctionError';
  }
}

// Wrapper pour Cloud Functions
export function wrapFunction<T>(
  handler: (data: T, context: any) => Promise<any>
) {
  return async (data: T, context: any) => {
    try {
      return await handler(data, context);
    } catch (error) {
      console.error('Function error:', error);
      
      if (error instanceof FunctionError) {
        throw new functions.https.HttpsError(
          'internal',
          error.message,
          { code: error.code }
        );
      }
      
      throw new functions.https.HttpsError(
        'internal',
        'Une erreur interne est survenue'
      );
    }
  };
}
```

-----

## 7. CLOUD FUNCTIONS

### Structure

```
functions/
├── src/
│   ├── index.ts                 # Export des fonctions
│   ├── triggers/                # Firestore triggers
│   │   ├── onEventCreated.ts
│   │   ├── onEventUpdated.ts
│   │   └── onVoteSubmitted.ts
│   ├── callable/                # Fonctions HTTP callable
│   │   ├── validateEvent.ts
│   │   ├── sendInvitation.ts
│   │   └── generateAISummary.ts
│   ├── scheduled/               # Fonctions planifiées (cron)
│   │   ├── checkEventDeadlines.ts
│   │   └── cleanupPastEvents.ts
│   └── utils/
│       ├── admin.ts             # Firebase Admin setup
│       ├── notifications.ts
│       └── ai.ts
├── package.json
└── tsconfig.json
```

### Exemples de Fonctions

```typescript
// functions/src/triggers/onEventCreated.ts
import * as functions from 'firebase-functions';
import { getFirestore } from 'firebase-admin/firestore';
import { sendNotificationToGroup } from '../utils/notifications';

export const onEventCreated = functions.firestore
  .document('events/{eventId}')
  .onCreate(async (snap, context) => {
    const event = snap.data();
    const eventId = context.params.eventId;
    
    // Récupérer les membres du groupe
    const db = getFirestore();
    const groupDoc = await db.collection('groups').doc(event.groupId).get();
    
    if (!groupDoc.exists) {
      console.error('Group not found:', event.groupId);
      return;
    }
    
    const group = groupDoc.data();
    const memberIds = group?.members.map((m: any) => m.userId) || [];
    
    // Envoyer notification à tous les membres
    await sendNotificationToGroup(
      memberIds,
      {
        title: `Nouvel événement : ${event.title}`,
        body: `${event.createdBy} a créé un événement dans ${group.name}`,
        data: {
          type: 'new_event',
          eventId,
          groupId: event.groupId,
        }
      }
    );
    
    console.log(`Notifications sent for event ${eventId}`);
  });
```

```typescript
// functions/src/triggers/onVoteSubmitted.ts
import * as functions from 'firebase-functions';
import { getFirestore } from 'firebase-admin/firestore';

export const onVoteSubmitted = functions.firestore
  .document('events/{eventId}')
  .onUpdate(async (change, context) => {
    const before = change.before.data();
    const after = change.after.data();
    const eventId = context.params.eventId;
    
    // Vérifier si c'est un nouveau vote
    const voteCountBefore = before.dateOptions?.reduce(
      (acc: number, opt: any) => acc + (opt.votes?.length || 0),
      0
    ) || 0;
    
    const voteCountAfter = after.dateOptions?.reduce(
      (acc: number, opt: any) => acc + (opt.votes?.length || 0),
      0
    ) || 0;
    
    if (voteCountAfter <= voteCountBefore) return;
    
    // Vérifier si on atteint le seuil de validation auto
    const db = getFirestore();
    const groupDoc = await db.collection('groups').doc(after.groupId).get();
    const totalMembers = groupDoc.data()?.members.length || 0;
    
    for (const option of after.dateOptions) {
      const yesVotes = option.votes?.filter((v: any) => v.response === 'yes').length || 0;
      const threshold = totalMembers * 0.8; // 80%
      
      if (yesVotes >= threshold && after.status === 'voting') {
        // Auto-validation
        await change.after.ref.update({
          status: 'confirmed',
          chosenDate: {
            start: option.start,
            end: option.end,
            confirmedBy: 'system',
            confirmedAt: new Date(),
          },
        });
        
        console.log(`Event ${eventId} auto-validated`);
        break;
      }
    }
  });
```

```typescript
// functions/src/callable/generateAISummary.ts
import * as functions from 'firebase-functions';
import { getFirestore } from 'firebase-admin/firestore';
import { generateSummary } from '../utils/ai';

interface SummaryRequest {
  eventId: string;
}

export const generateAISummary = functions.https.onCall(
  async (data: SummaryRequest, context) => {
    // Vérifier auth
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'User must be authenticated'
      );
    }
    
    const { eventId } = data;
    const db = getFirestore();
    
    // Récupérer l'événement
    const eventDoc = await db.collection('events').doc(eventId).get();
    if (!eventDoc.exists) {
      throw new functions.https.HttpsError(
        'not-found',
        'Event not found'
      );
    }
    
    // Récupérer les messages
    const messagesSnap = await db
      .collection('events')
      .doc(eventId)
      .collection('messages')
      .orderBy('timestamp', 'asc')
      .limit(50)
      .get();
    
    const messages = messagesSnap.docs.map(doc => ({
      sender: doc.data().senderId,
      text: doc.data().text,
    }));
    
    // Générer résumé avec IA
    const summary = await generateSummary(messages);
    
    return { summary };
  }
);
```

```typescript
// functions/src/scheduled/checkEventDeadlines.ts
import * as functions from 'firebase-functions';
import { getFirestore } from 'firebase-admin/firestore';
import { sendNotification } from '../utils/notifications';

// Exécuter toutes les heures
export const checkEventDeadlines = functions.pubsub
  .schedule('every 1 hours')
  .onRun(async (context) => {
    const db = getFirestore();
    const now = new Date();
    const in48Hours = new Date(now.getTime() + 48 * 60 * 60 * 1000);
    
    // Trouver événements en vote avec deadline proche
    const eventsSnap = await db
      .collection('events')
      .where('status', '==', 'voting')
      .get();
    
    for (const eventDoc of eventsSnap.docs) {
      const event = eventDoc.data();
      const earliestDate = event.dateOptions
        .map((opt: any) => opt.start.toDate())
        .sort((a: Date, b: Date) => a.getTime() - b.getTime())[0];
      
      if (earliestDate && earliestDate <= in48Hours) {
        // Envoyer rappel aux membres qui n'ont pas voté
        const groupDoc = await db.collection('groups').doc(event.groupId).get();
        const allMembers = groupDoc.data()?.members.map((m: any) => m.userId) || [];
        
        const votedMembers = new Set(
          event.dateOptions.flatMap((opt: any) => 
            opt.votes?.map((v: any) => v.userId) || []
          )
        );
        
        const nonVoters = allMembers.filter((id: string) => !votedMembers.has(id));
        
        for (const userId of nonVoters) {
          await sendNotification(userId, {
            title: 'Rappel : Vote requis',
            body: `Il reste moins de 48h pour voter sur "${event.title}"`,
            data: {
              type: 'vote_reminder',
              eventId: eventDoc.id,
            }
          });
        }
        
        console.log(`Reminders sent for event ${eventDoc.id}`);
      }
    }
    
    return null;
  });
```

### Utilitaires Cloud Functions

```typescript
// functions/src/utils/notifications.ts
import { getMessaging } from 'firebase-admin/messaging';
import { getFirestore } from 'firebase-admin/firestore';

interface NotificationPayload {
  title: string;
  body: string;
  data?: Record<string, string>;
}

export async function sendNotification(
  userId: string,
  payload: NotificationPayload
): Promise<void> {
  const db = getFirestore();
  const userDoc = await db.collection('users').doc(userId).get();
  
  if (!userDoc.exists) {
    console.warn('User not found:', userId);
    return;
  }
  
  const fcmToken = userDoc.data()?.fcmToken;
  if (!fcmToken) {
    console.warn('No FCM token for user:', userId);
    return;
  }
  
  try {
    await getMessaging().send({
      token: fcmToken,
      notification: {
        title: payload.title,
        body: payload.body,
      },
      data: payload.data || {},
      webpush: {
        fcmOptions: {
          link: payload.data?.actionURL || '/',
        }
      }
    });
    
    // Enregistrer notification dans Firestore
    await db.collection('notifications').doc(userId).collection('items').add({
      ...payload,
      read: false,
      createdAt: new Date(),
    });
    
  } catch (error) {
    console.error('Error sending notification:', error);
  }
}

export async function sendNotificationToGroup(
  memberIds: string[],
  payload: NotificationPayload
): Promise<void> {
  await Promise.all(
    memberIds.map(userId => sendNotification(userId, payload))
  );
}
```

```typescript
// functions/src/utils/ai.ts
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!);

interface Message {
  sender: string;
  text: string;
}

export async function generateSummary(messages: Message[]): Promise<string> {
  const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
  
  const prompt = `
Tu es un assistant pour une application d'organisation d'événements entre amis.
Analyse cette conversation et extrais :
1. Les décisions prises (date, lieu, horaire)
2. Les informations pratiques importantes
3. Qui apporte quoi

Messages :
${messages.map(m => `- ${m.text}`).join('\n')}

Réponds de manière concise et structurée.
`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

export async function detectConflicts(
  userId: string,
  proposedDate: Date
): Promise<string[]> {
  // Récupérer autres événements de l'utilisateur
  const db = getFirestore();
  const eventsSnap = await db
    .collection('events')
    .where('status', '==', 'confirmed')
    .get();
  
  const conflicts: string[] = [];
  
  for (const doc of eventsSnap.docs) {
    const event = doc.data();
    const eventDate = event.chosenDate?.start.toDate();
    
    if (eventDate && 
        Math.abs(eventDate.getTime() - proposedDate.getTime()) < 3 * 60 * 60 * 1000) {
      conflicts.push(event.title);
    }
  }
  
  return conflicts;
}
```

-----

## 8. TESTS

### Configuration Jest

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@components/(.*)$': '<rootDir>/src/components/$1',
    '^@hooks/(.*)$': '<rootDir>/src/hooks/$1',
    '^@services/(.*)$': '<rootDir>/src/services/$1',
    '^@utils/(.*)$': '<rootDir>/src/utils/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/main.tsx',
    '!src/**/*.stories.tsx',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
};
```

### Tests Unitaires

```typescript
// src/utils/__tests__/date.utils.test.ts
import { DateUtils } from '../date.utils';

describe('DateUtils', () => {
  describe('formatEventDate', () => {
    it('should format date correctly in French', () => {
      const date = new Date('2024-12-25');
      const result = DateUtils.formatEventDate(date);
      expect(result).toMatch(/décembre 2024/);
    });
  });

  describe('isEventUrgent', () => {
    it('should return true for events within 48 hours', () => {
      const urgentDate = new Date(Date.now() + 24 * 60 * 60 * 1000);
      expect(DateUtils.isEventUrgent(urgentDate)).toBe(true);
    });

    it('should return false for events beyond 48 hours', () => {
      const futureDate = new Date(Date.now() + 72 * 60 * 60 * 1000);
      expect(DateUtils.isEventUrgent(futureDate)).toBe(false);
    });

    it('should return false for past events', () => {
      const pastDate = new Date(Date.now() - 24 * 60 * 60 * 1000);
      expect(DateUtils.isEventUrgent(pastDate)).toBe(false);
    });
  });
});
```

```typescript
// src/components/__tests__/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../common/Button';

describe('Button', () => {
  it('should render with label', () => {
    render(<Button label="Click me" onClick={() => {}} />);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('should call onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button label="Click me" onClick={handleClick} />);
    
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('should be disabled when disabled prop is true', () => {
    render(<Button label="Click me" onClick={() => {}} disabled />);
    expect(screen.getByText('Click me')).toBeDisabled();
  });

  it('should apply variant class', () => {
    const { container } = render(
      <Button label="Click me" onClick={() => {}} variant="secondary" />
    );
    expect(container.firstChild).toHaveClass('btn-secondary');
  });
});
```

### Tests d'Intégration

```typescript
// src/services/__tests__/firestore.service.test.ts
import { FirestoreService } from '../firestore.service';
import { initializeTestEnvironment } from '@firebase/rules-unit-testing';

describe('FirestoreService', () => {
  let testEnv: any;

  beforeAll(async () => {
    testEnv = await initializeTestEnvironment({
      projectId: 'test-project',
      firestore: {
        rules: `
          rules_version = '2';
          service cloud.firestore {
            match /databases/{database}/documents {
              match /{document=**} {
                allow read, write: if true;
              }
            }
          }
        `,
      },
    });
  });

  afterAll(async () => {
    await testEnv.cleanup();
  });

  it('should create an event', async () => {
    const eventData = {
      groupId: 'group1',
      title: 'Test Event',
      description: 'Test Description',
      status: 'idea' as const,
      createdBy: 'user1',
      organizerIds: ['user1'],
      dateOptions: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const eventId = await FirestoreService.createEvent(eventData);
    expect(eventId).toBeDefined();
    expect(typeof eventId).toBe('string');
  });
});
```

-----

## 9. PERFORMANCE & OPTIMISATION

### Code Splitting

```typescript
// src/App.tsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { LoadingSpinner } from '@components/common/LoadingSpinner';

// Lazy loading des pages
const Dashboard = lazy(() => import('@pages/Dashboard'));
const GroupDetail = lazy(() => import('@pages/GroupDetail'));
const EventDetail = lazy(() => import('@pages/EventDetail'));
const Profile = lazy(() => import('@pages/Profile'));

export function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/groups/:groupId" element={<GroupDetail />} />
          <Route path="/events/:eventId" element={<EventDetail />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

### Memoization

```typescript
// src/components/EventCard.tsx
import { memo, useMemo } from 'react';

interface EventCardProps {
  event: Event;
  onVote: (optionId: string, response: VoteResponse) => void;
}

export const EventCard = memo<EventCardProps>(({ event, onVote }) => {
  // Calcul coûteux mis en cache
  const voteStats = useMemo(() => {
    return event.dateOptions.map(option => ({
      optionId: option.optionId,
      yesCount: option.votes.filter(v => v.response === 'yes').length,
      maybeCount: option.votes.filter(v => v.response === 'maybe').length,
      noCount: option.votes.filter(v => v.response === 'no').length,
    }));
  }, [event.dateOptions]);

  return (
    <div className="event-card">
      {/* Render */}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison pour éviter re-renders inutiles
  return prevProps.event.id === nextProps.event.id &&
         prevProps.event.updatedAt === nextProps.event.updatedAt;
});
```

### Image Optimization

```typescript
// src/components/common/Avatar.tsx
interface AvatarProps {
  src: string;
  alt: string;
  size?: 'sm' | 'md' | 'lg';
}

export const Avatar: React.FC<AvatarProps> = ({ src, alt, size = 'md' }) => {
  const sizeMap = {
    sm: 32,
    md: 40,
    lg: 80,
  };

  const dimension = sizeMap[size];

  // Optimisation image avec Firebase Storage
  const optimizedSrc = src.includes('firebasestorage.googleapis.com')
    ? `${src}?alt=media&w=${dimension}&h=${dimension}&fit=crop`
    : src;

  return (
    <img
      src={optimizedSrc}
      alt={alt}
      width={dimension}
      height={dimension}
      loading="lazy"
      className="avatar"
    />
  );
};
```

### Firestore Query Optimization

```typescript
// ❌ Mauvais : Fetch tous les événements puis filtre en JS
const allEvents = await FirestoreService.getAllEvents();
const confirmedEvents = allEvents.filter(e => e.status === 'confirmed');

// ✅ Bon : Filtre côté serveur
const confirmedEvents = await FirestoreService.getEventsByStatus('confirmed');

// ❌ Mauvais : Lecture dans boucle (N+1)
for (const userId of userIds) {
  const user = await FirestoreService.getUserById(userId);
  users.push(user);
}

// ✅ Bon : Batch read
const users = await FirestoreService.getUsersByIds(userIds);
```

### Debounce & Throttle

```typescript
// src/hooks/useDebounce.ts
import { useEffect, useState } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Utilisation dans search
function SearchBar() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);

  useEffect(() => {
    if (debouncedQuery) {
      // Effectuer recherche
      searchEvents(debouncedQuery);
    }
  }, [debouncedQuery]);

  return <input value={query} onChange={e => setQuery(e.target.value)} />;
}
```

-----

## 10. SÉCURITÉ

### Variables d'Environnement

```bash
# .env.example
VITE_FIREBASE_API_KEY=your_api_key
VITE_FIREBASE_AUTH_DOMAIN=your_auth_domain
VITE_FIREBASE_PROJECT_ID=your_project_id
VITE_FIREBASE_STORAGE_BUCKET=your_storage_bucket
VITE_FIREBASE_MESSAGING_SENDER_ID=your_sender_id
VITE_FIREBASE_APP_ID=your_app_id
VITE_GOOGLE_AI_API_KEY=your_ai_api_key

# Ne jamais commiter .env.local
```

```typescript
// src/config/env.ts
const requiredEnvVars = [
  'VITE_FIREBASE_API_KEY',
  'VITE_FIREBASE_AUTH_DOMAIN',
  'VITE_FIREBASE_PROJECT_ID',
] as const;

// Validation au démarrage
for (const varName of requiredEnvVars) {
  if (!import.meta.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
}

export const env = {
  firebase: {
    apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
    authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
    projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
    storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
    messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
    appId: import.meta.env.VITE_FIREBASE_APP_ID,
  },
  googleAI: {
    apiKey: import.meta.env.VITE_GOOGLE_AI_API_KEY,
  },
} as const;
```

### Input Sanitization

```typescript
// Toujours valider et sanitizer les inputs utilisateur
function createEvent(data: any) {
  const sanitized = {
    title: ValidationUtils.sanitizeInput(data.title),
    description: ValidationUtils.sanitizeInput(data.description),
    // ...
  };

  if (!ValidationUtils.isValidEventTitle(sanitized.title)) {
    throw new AppError('Invalid title', ERROR_CODES.INVALID_INPUT);
  }

  return FirestoreService.createEvent(sanitized);
}
```

### CORS Configuration (Cloud Functions)

```typescript
// functions/src/index.ts
import * as functions from 'firebase-functions';
import * as cors from 'cors';

const corsHandler = cors({
  origin: [
    'https://events-app.web.app',
    'https://events-app.firebaseapp.com',
    ...(process.env.NODE_ENV === 'development' ? ['http://localhost:5173'] : []),
  ],
  credentials: true,
});

export const myFunction = functions.https.onRequest((req, res) => {
  return corsHandler(req, res, async () => {
    // Function logic
  });
});
```

-----

## 11. CI/CD & DÉPLOIEMENT
